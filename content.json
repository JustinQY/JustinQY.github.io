{"posts":[{"title":"","text":"有监督学习的一种: 二分类问题 问题类型描述对于一定的输入数据(input dataset), 其对应的输出结果是有限的, 可选的几个数之一, 而不是实数范围内的无限种可能之一. 例如判断一个患者的肿瘤是良性还是恶性; 判断一笔网络上的交易是否诈骗; 判断一封电子邮件是不是垃圾邮件等. 对于这些问题的结果预测(prediction)只能是yes or no(是或否, 1或0)中的一个. 逻辑回归尝试使用线性回归模型解决此类问题, 会发现对于输入集合较少的一些情况下, 模型预测的结果可能是ok的. 但是在数据量较大或不断增加输入数据时, 随着线性回归模型的不断学习, 模型的预测结果甚至会越来越差! 事实上, 用线性回归模型来预测classification问题的结果是糟糕的, 实际结果(y)不再像线性回归问题中散乱分布的点那样, 我们可以找到一条尽量与这些点拟合的直线来作为模型进行结果预测(以一维输入数据举例). 在classification问题中, y的取值只有0和1, 因此我们想要把模型的预测结果映射到0到1这个范围区间内, 这样可以更好地得到对于输入数据的有效预测(0或1). 因此引入sigmoid函数. sigmoid函数会把上面线性回归模型的结果mapping到0到1之间的数上.","link":"/2024/05/21/Binary%20Classification/"},{"title":"","text":"","link":"/2024/05/21/Decision%20Boundary/"},{"title":"","text":"","link":"/2024/05/21/Logistic%20Regression/"},{"title":"","text":"搭建个人python虚拟环境: 新建一个文件夹目录, 假设叫做“deeplearning”. 执行 python3 -m venv venv, 第一个“venv”表示创建virtual environment, 后面的“venv”表示环境文件夹命名. 执行 source venv/bin/activate以激活python虚拟环境, 回车后看到后续命令行内容中包含(venv)表示已经成功进入python虚拟环境.","link":"/2024/05/20/python%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"title":"","text":"1. 线性回归 通过线性函数来对dataset进行拟合, 再对新的dateset做出预测. 单变量线性回归模型: f_wb(x) = wx + b","link":"/2024/06/01/%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B(regression%20model)_%E5%89%AF%E6%9C%AC/"},{"title":"","text":"0.什么是机器学习 赋予计算机无需明确编程即可学习的能力的研究领域. 1.监督学习 根据输入数据(x)和正确结果(y)训练模型, 而后用模型对新输入数据(x_new)给出准确的输出预测, 即“input x”和“output y”的“mapping”过程.(Data has “right answers”!) 回归问题(regression): 从无限个可能的结果中预测一个数字 分类问题(classification): 从少量可能的输出中预测类别(classes, categories) 分类问题中机器学习模型会找到一个边界(boundary line)来对不同的输入数据做出类别预测 2.无监督学习 在未标记的数据中找到一些东西(有什么图案, 有什么结构…), 不对模型进行学习训练(只有输入数据x, 没有输出结果y). 例如 clustering algorithm clustering algorithm(聚类算法): 例如 Google news中的related articles, DNA microarray, grouping customers","link":"/2024/06/01/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%20vs.%20%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0_%E5%89%AF%E6%9C%AC/"},{"title":"订阅测试2","text":"","link":"/2024/07/05/%E8%AE%A2%E9%98%85%E6%B5%8B%E8%AF%952/"},{"title":"","text":"","link":"/2024/07/04/%E9%93%BE%E8%A1%A8/"},{"title":"Python List使用","text":"列表创建 创建一个一维空列表, 长度为01nums = [] 创建一个二维空列表, 行和列长度为n1nums = [[None for _ in range(n)] for _ in range(n)] 列表的几种遍历方式: 从0到nums列表最后一位顺序遍历法, i表示下标 (nums[0], nums[1]...nums[n-1])1for i in range(len(nums)) 遍历由[left, right]左右闭区间组成的nums子串, x表示这个区间的每一个nums元素 1for x in nums[left:right] 从left下标开始, 到right-1结束, 以step为步长, 遍历这个区间. i表示下标 12345for i in range(left, right, step)# 注意: 遍历区间是**左闭右开**区间, 即`[left, right)`.# 如果需要左右闭区间遍历, 则需要: `range(left, right + 1, step)`# 反向闭区间遍历: `range(left - 1, right, step)` 从left下标开始, 到right-1结束, 以step为步长, 遍历这个区间. i表示下标 1for i in range(left, right, step) 列表获取子区间 123[x for x in nums[left:right]][nums[i] for i in range(left, right, step)] 列表添加元素 添加单个元素到列表尾部, 如nums.append(x) 1append() 添加一个可迭代对象（如列表、元组、字符串等）的所有元素到列表尾部, 如nums.extend([4, 5, 6]) 1extend()","link":"/2024/07/03/%E5%88%97%E8%A1%A8/"},{"title":"订阅测试","text":"","link":"/2024/07/05/%E8%AE%A2%E9%98%85%E6%B5%8B%E8%AF%95/"},{"title":"iOS MJExtension","text":"MJExtension – Json转Model一. Json数据定义：JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。JSON采用完全独立于语言的文本格式，这些特性使JSON成为理想的数据交换语言。易于人阅读和编写，同时也易于机器解析和生成。 —– Json可以将js对象中表示的一组数据转换为字符串，然后就可以在函数之间传递这个字符串，且js很容易解析它。 基础结构： “名称/值”对的集合（A collection of name/value pairs）。不同的语言中，它被理解为对象（object），记录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。 值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）。 实例： 名称/值 {“firstName”:”Mary”, “lastName”:”Frank”, “email”:”gmail”} 表示数组 { “people”: [ { “firstName”: “Brett”, “lastName”:”McLaughlin”, “email”: “aaaa” }, { “firstName”: “Jason”, “lastName”:”Hunter”, “email”: “bbbb”}, { “firstName”: “Elliotte”, “lastName”:”Harold”, “email”: “cccc” } ]} 特点： Json是完全动态的，允许在Json结构中改变表示数据的方式 二. MJExtension的使用","link":"/2024/07/04/iOS/iOS_MJExtension/"},{"title":"NSTimer","text":"","link":"/2024/07/04/iOS/iOS_NSTimer/"},{"title":"iOS之MRC与ARC","text":"内存管理模型一. 需要进行内存管理的对象 任何继承了NSObject的对象需要进行内存管理 非对象类型(int、char、float、double、struct、enum等) 不需要进行内存管理 二. 内存结构1. 堆一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，分配方式类似于链表，继承了NSObject的对象存储在堆中。 2. 栈由操作系统自动分配释放，存放函数的参数值，局部变量的值等，分配方式类似于栈。 3. 数据段（data区）4. 代码段（text区）三. OC内存管理模型1. 自动垃圾收集（iOS运行环境不支持）2. 手动引用计数（MRC）和自动释放池（AutoReleasePool）3. 自动引用计数（ARC）四. MRC &amp; AutoReleasePool – 手动引用计数与自动释放池1. 引用计数器引用计数器是一个整数，即对象被引用的次数。系统根据对象的引用计数器判断何时应该回收它所占用的内存。每个OC对象都有自己的引用计数器，任何对象刚创建的时候，引用计数器为1。 2. 引用计数器的操作 每当创建引用到对象需要给对象发送一条retain消息，此时该对象引用计数器值**+1。** 每当不需要该对象时给对象发送一条release消息，此时该对象引用计数器值**-1** 给对象发送retainCount消息，可以获得当前对象引用计数器值。 当对象的引用计数器值为0时，系统通过给该对象发送dealloc消息，释放该对象的内存。 3. dealloc 对象即将被销毁时系统会自动给对象发送一条dealloc消息。 一般会重写dealloc方法，即在这里释放相关资源，该方法一旦重写，必须在方法最后调用**[super dealloc]**。 不能直接调用dealloc方法。 4. 野指针和空指针 当一个指针指向一个“僵尸对象”（被释放了的对象），这个指针就是野指针。 为避免给野指针发送消息报错，在它指向的对象被释放后，将它设置为空指针（没有指向存储空间的指针）。 5. 自动释放池 – AutoReleasePool autorelease是一种支持引用计数的内存管理方式，给对象发送一条autorelease信息，会将对象放到一个自动释放池中，当自动释放池被销毁时，会对池子中的所有对象发送一次release消息（只是发送release消息，并不是将对象直接释放）。 autorelease方法会返回对象本身，其实质上是延迟了给对象发送release消息的操作。 NSAutoreleasePool *pool创建等同与@autoreleasepool创建，前者需要调用 [pool drain]来销毁自动释放池。 自动释放池中不适宜放占用内存较大的对象或大量循环操作。 6. 循环retain 当A对象要拥有B对象，同时B对象要拥有A对象，此时会形成循环retain，导致A和B对象永远无法释放。 尽量避免双端互相引用，或者一端用retain，一端用assign。 五. ARC – 自动引用计数1. ARC自动引用计数，系统检测出何时需要保持对象，何时需要自动释放对象，编译器会管理内存，并在合适的地方加入retain，release和autorelease。 2. ARC的判断原则 – 强指针 ARC通过强指针判断一个对象是否需要释放。 默认所有对象的指针变量都是强指针，或者被“__strong”修饰的指针。 被**__weak修饰的指针是弱指针**。 只要还有一个强指针变量指向对象，对象就会保持在内存中。 3. ARC的注意事项 不能调用对象的release方法。 不能调用autorelease方法。 重写dealloc方法时，不能调用**[super dealloc]**。 4. 单对象内存管理 局部变量（局部强指针）超出作用域释放，对象随之被释放。 清空指针（默认清空的所有指针都是强指针），对象随之被释放。 弱指针保存新创建的对象时，对象会立即被释放。 5. 多对象内存管理 想要拥有某个对象必须使用强指针保存它，无需在dealloc方法中release。 6. property参数 strong：用于OC对象，相当于MRC中的retain。 weak：用于OC对象，相当于MRC中的assign。 assign：用于基本数据类型，与MRC中的assign相同。 7. 循环引用如果A拥有B，B也拥有A，那么其中一方必须使用弱指针。","link":"/2024/07/04/iOS/iOS_MRC%E4%B8%8EARC/"},{"title":"UICollectionView学习笔记","text":"学习UICollectionViewUICollectionView的组成 Cell – 用于展示内容，尺寸和内容可以各不相同。 Supplementary Views – 追加视图，类似于UITableView中每个Section的Header或Footer Decoration View – 装饰视图，跟数据无关，为Cell和Supplementary Views添加辅助视图。 所有的UICollectionView都有该三个部件组成 UICollectionView的实现 dataSource – 为View提供数据源，给View提供需要显示的数据&nbsp;&nbsp;&nbsp;方法：&nbsp;&nbsp;&nbsp;1). numberOfSectionsInCollectionView: &nbsp;–&nbsp; 获取section数量&nbsp;&nbsp;&nbsp;2). collectionView:numberOfItemsInSection: &nbsp;–&nbsp; 获取某个section中item的数量&nbsp;&nbsp;&nbsp;3). collectionView:cellForItemAtIndexPath: &nbsp;–&nbsp; 对于某个位置的cell是怎样的&nbsp;&nbsp;&nbsp;4). collectionView:viewForSupplementaryElementOfKind:atIndexPath: &nbsp;–&nbsp; 对于某个位置的section显示怎样的Supplementary View delegate – 负责实现与用户交互的相应，为样式实现一些细节 &nbsp; &nbsp; 交互举例: &nbsp;&nbsp;&nbsp;1).cell高亮 &nbsp;&nbsp;&nbsp;2).cell选中时的状态 &nbsp;&nbsp;&nbsp;3).长按后的菜单显示 &nbsp;&nbsp;&nbsp;监听cell点击：(当用户点击cell时触发的delegate询问) &lt;点击事件发生&gt; &nbsp;&nbsp;&nbsp; 1).-collectionView:shouldHighlightItemAtIndexPath:&nbsp;–&nbsp;是否应该高亮？ &nbsp;&nbsp;&nbsp; 2).-collectionView:didHighlightItemAtIndexPath:&nbsp;–&nbsp;确认显示高亮（如果1返回YES则执行，否则不执行） &lt;点击事件结束(手指抬起)&gt; &nbsp;&nbsp;&nbsp; 3).-collectionView:shouldSelectItemAtIndexPath:&nbsp;–&nbsp;是否应该选中被点击的cell(如果1返回NO这里不再询问询问是否选中) &nbsp;&nbsp;&nbsp; 4).-collectionView:didSelectItemAtIndexPath:&nbsp;–&nbsp;确认选中被点击的cell(如果3中返回选中，调用选中) &nbsp;&nbsp;&nbsp; 5).-collectionView:didUnhighlightItemAtIndexPath:&nbsp;–&nbsp;确认取消高亮(如果1返回YES，那么会调用取消高亮) UICollectionViewLayout – 为CollectionView定义一些独特的布局 UICollectionView子视图的复用UICollectionView中所有视图都来自一个可复用的基类 –&gt; UICollectionReusableView， 在UICollectionView中，对于cell，Supplementary View和Decoration View都是需要复用的。 UICollectionVIewCell的组成相比于UITableViewCell，UICollectionViewCell不存在style，没有titleLabel和内置的imageView属性1.cell &nbsp;&nbsp;&nbsp;–&nbsp;&nbsp;&nbsp; 在这里是UICollectionReusableView 2.backgroundvView &nbsp;&nbsp;&nbsp;–&nbsp;&nbsp;&nbsp; cell的背景视图，可以设置背景图片 3.selectedBackgroundView &nbsp;&nbsp;&nbsp;–&nbsp;&nbsp;&nbsp; cell被选中时的背景视图 4.contentView &nbsp;&nbsp;&nbsp;–&nbsp;&nbsp;&nbsp; 内容视图，自定义cell时将内容放在这个View上 布局 – UICollectionViewLayoutUICollectionViewLayout是UICollectionView特有的，可以将每个cell, Supplementary View和Decoration View进行组合，为它们设置各自的属性(位置，大小，透明度，层级关系，形状等)。它可以决定UICollectionView如何显示在界面上。 1.流水布局(线性布局) &nbsp;&nbsp;&nbsp;–&nbsp;&nbsp;&nbsp;UICollectionViewFlowLayout &nbsp;&nbsp;&nbsp;&nbsp;属性： ​ 1).CGSize itemSize &nbsp;–&nbsp;定义每一个item的size，可以快捷地给cell设置大小&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2).CGFloat minimumLineSpacing &nbsp;–&nbsp;最小行间距&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3).CGFloat minimumInteritemSpacing &nbsp;–&nbsp;最小cell之间的距离&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4).UIEdgeInsets sectionInset &nbsp;–&nbsp;设置UIcollectionView整体的组内边距&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5).CGSize headerReferenceSize &nbsp;–&nbsp;设置supplementary header View的大小&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6).CGSize footerReferenceSize &nbsp;–&nbsp;设置supplementary footer View的大小&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7).UICollectionViewScrollDirection scrollDirection &nbsp;–&nbsp;设置UICollectionView的滚动方向 2.UICollectionViewAttributes布局属性 &nbsp;&nbsp;&nbsp;&nbsp;属性： ​ 1).CGRect frame &nbsp;–&nbsp;布局视图的frame&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2).CGPoint center &nbsp;–&nbsp;视图中心点&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3).CGSize size &nbsp;–&nbsp;视图尺寸&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;4).CGAffineTransform transform &nbsp;–&nbsp;转场属性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5).CGFloat alpha &nbsp;–&nbsp;透明度&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6).NSInteger zIndex &nbsp;–&nbsp;层级(数字越大，层级越高)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7).registerClass:forDecorationViewOfKind &nbsp;–&nbsp;注册Decoration View 3.UICollectionViewLayout自定义布局 ​ 一些处理布局的方法 ​ 1).@interface UICollectionViewLayout (UISubclassingHooks) 布局UICollectiojnView的子视图 ​ 2).@interface UICollectionViewLayout (UIUpdateSupportHooks) 布局删除插入动作 ​ 3).@interface UICollectionViewLayout (UIReorderingSupportHooks) 移动动作布局","link":"/2024/07/04/iOS/iOS_UICollectionView%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"ObjectiveC 小记","text":"记录一些Objective-C的使用技巧和注意事项, 也算是对iOS开发生涯的总结~~~(in progress) 面向对象思想 面向对象和面向过程的区别 面向过程强调功能行为，关注解决问题需要哪些步骤 (所有过程亲力亲为) 面向对象将功能封装进对象，强调具备了功能的对象，关注的是解决问题需要哪些对象 (找到具有对应功能的对象，让对象去做事情) 面向对象思想在完成需求中的运用先去找具有所需功能的对象来用, 如果该对象那个不存在，那么创建一个具有该功能的对象 类与对象对象是由类创建的，因此应先考虑设计哪些类，再考虑用类创建哪些对象 类的设计描述一个类，主要描述该类的属性和行为，即成员变量和成员方法 类的分析 一般名词都是类 拥有类似属性和行为的对象可以抽象成一个类 OC中类的本质是一个结构体 类的声明 类的声明以@interface开头，以@end结尾，写上类名和继承的类，类名首字母大写，告诉系统类中有哪些属性和行为 OC类声明中属性只能写在interface和end中的大括号中，建议将属性名称前面都加上 “_” 类的实现 以@implement开头，以@end结尾 类中方法的实现 对象的创建 用类创建对象，必须给类发送一个消息 如何发送消息 [类名称/对象名称 方法名称] 发送什么消息 new 用什么保存新创建的对象 指针 对象方法 减号开头 只能由对象调用 类方法 加号开头 只能由类，即用类名调用 某个功能经常被使用，避免每次为了使用该方法而开辟新对象浪费存储空间，可将它声明为类方法 注意事项 OC中的”（）“是专门用来扩住数据类型的， 如 - (int)signal:(int) number; 类方法和对象方法的区别 对象方法必须由对象调用，类方法必须由类调用 类方法中不能直接访问该类的属性变量，对象方法可以直接访问类的属性变量 类方法的调用效率会比调用对象方法高 类方法和对象方法可以相互调用 对象方法中可以直接调用类方法 类方法中可以直接调用对象方法 类方法中可以直接调用类方法 对象方法中可以直接调用对象方法 主头文件 &lt;Foundation/Foundation.h&gt; 主头文件中拷贝了该工具箱中所有工具的头文件，只需导入主头文件就可使用该工具箱中所有的工具，避免每次使用都要导入一个对应头文件。 OC是C语言的超集，相当于在C语言上增加了面向对象的部分，因此C语言程序，C++程序可以在OC项目中编译。 property参数 成员变量前加@property，系统会自动生成getter/setter方法 加上retain，系统自动生成getter/setter方法，但是需要重写dealloc方法 默认情况下是assign","link":"/2024/07/04/iOS/iOS_ObjectiveC%E5%B0%8F%E8%AE%B0/"},{"title":"NSThread","text":"创建子线程123456789101112131415161718192021222324252627282930313233343536373839//线程创建方法1 -- allo + init- (void)createThread1 { /* 第一个参数：目标对象 self 第二个参数：方法选择器 -&gt; 调用的方法 第三个参数：前面调用的方法需要传递的参数 -&gt; nil */ NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run:) object:@&quot;test&quot;]; //启动线程 [thread start]; //设置线程属性 thread.name = @&quot;线程A&quot;; [thread setName:@&quot;线程A&quot;]; //设置线程优先级 -- 优先级大小(0.0 ~ 1.0), 默认为0.5 thread.threadPriority = 1.0; //线程生命周期 -- 当任务执行完成之后被释放}//线程创建方法2 -- 无法获取创建的线程对象- (void)createThread2 { //分离子线程方法 [NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:@&quot;通过分离子线程创建新线程&quot;];}//线程创建方法3-- 无法获取创建的线程对象- (void)createThread3 { //开启后台线程方法 [self performSelectorInBackground:@selector(run:) withObject:@&quot;通过开启后台线程创建新线程&quot;];}- (void)test:(NSString *)para { NSLog(@&quot;-----test-----%@&quot;, [NSThread currentThread]);} 子线程状态切换12345678910111213141516171819- (void)createThread1 { //新建状态 NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run:) object:@&quot;test&quot;]; //就绪或运行状态 [thread start];}- (void)test:(NSString *)para { NSLog(@&quot;-----test-----%@&quot;, [NSThread currentThread]); //阻塞状态 [NSThread sleepFortimeinterval:2.0]; [NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:3.0]]; //死亡状态 [NSThread exit];} 回到: [[多线程2__多线程开发#实现汇总]] 线程间通信实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//网络图片下载Demo -- NSThread实现#import &quot;ViewController.h&quot;@interface ViewController ()@property(nonatomic, strong) UIImageView *imageView;@property(nonatomic, strong) NSThread *threadA;@end@implementation ViewController//耗时操作要用子线程进行- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event { //分离一条子线程去执行download方法 [NSThread detachNewThreadSelector:@selector(download) toTarget:self withObject:nil];}- (void)download { //确定图片URL NSURL *url = [NSURL URLWithString:@&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fa1.att.hudong.com%2F62%2F02%2F01300542526392139955025309984.jpg&amp;refer=http%3A%2F%2Fa1.att.hudong.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1613890070&amp;t=9b041b83f4ddfe8c165547120f5aa589&quot;]; //根据URL下载图片二进制数据到本地 NSData *imageData = [NSData dataWithContentsOfURL:url]; //图片格式转换 UIImage *image = [UIImage imageWithData:imageData]; //回到主线程显示UI的三种方法 //方法1 /* 参数1：回到主线程要调用的方法 参数2：前面方法需要的参数 参数3：当前方法剩余部分的执行是否等待参数1方法执行完毕 */ [self performSelectorOnMainThread:@selector(showImage:) withObject:image waitUntilDone:YES]; //方法2 -- 主动选择执行线程为主线程 [self performSelector:@selector(showImage:) onThread:[NSThread mainThread] withObject:image waitUntilDone:YES]; //方法3 -- 直接用self.imageView调用主线程方法 [self.imageView performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:YES]; }- (void)showImage:(UIImage *)image { self.imageView.image = image;}@end 回到: [[多线程2__多线程开发#线程间通信]]","link":"/2024/07/04/iOS/iOS_NSThread/"},{"title":"死锁","text":"使用disptach_sync在串行队列(包括主队列)导致的死锁问题原理解释:","link":"/2024/07/04/iOS/iOS_deadlock/"},{"title":"gcd","text":"GCD (grand central dispatch)概念gcd是一个强大的中枢调度器, 基于C语言实现, 解决多核的并行运算，能够自动利用更多的CPU内核，自动管理线程的生命周期. 任务: 执行什么操作(可以理解为函数的内容) 队列: 用来存放、安排任务. 不同的队列类型有不同的执行任务的策略.(串行队列在当前线程按顺序执行任务, 并发队列创建多个线程并行地执行任务) gcd的使用逻辑定制任务, 将任务添加到队列 – 先进先出地自动取出任务放到对应线程中执行 同步和异步同步和异步是指任务的类型 同步执行: 只能在当前线程执行任务，不能开启新线程 123456//使用block块封装任务dispatch_sync(dispatch_queue_t _Nonnull queue, ^{ });//使用函数封装任务dispatch_sync_f(dispatch_queue_t queue, void * context, dispatch_function_t work);//队列 - 函数形参(没有为null) - 调用函数名 异步执行: 可以开启新线程, 并在新线程中执行任务 123456//使用block块封装任务dispatch_async(dispatch_queue_t _Nonnull queue, ^{ });//使用函数封装任务dispatch_async_f(dispatch_queue_t queue, void * context, dispatch_function_t work); //队列 - 函数形参(没有为null) - 调用函数名 串行和并发串行和并发是指队列中任务的执行策略 并发队列 (Dispatch Concurrent Queue): 可以让多个任务并发执行 (自动开启多个线程同时执行任务) – 并发功能只在异步函数下生效 1234567//并发队列/*参数1：C语言字符串 -- 队列标签参数2：队列类型 DISPATCH_QUEUE_CONCURRENT -- 并发*/dispatch_queue_t queue = dispatch_queue_create(&quot;label1&quot;, DISPATCH_QUEUE_CONCURRENT); 全局并发队列: 默认存在，且对应有高，默认，低，后台优先级的四种并发队列，使用时只选择其中一个；而create函数是从0开始创建一个并发队列 123456//全局并发队列/*参数1：队列优先级参数2：默认为0*/dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0); 串行队列 (Dispatch Serial Queue): 让任务一个接一个地执行 12//串行队列dispatch_queue_t queue = dispatch_queue_create(&quot;label2&quot;, DISPATCH_QUEUE_SERIAL); 主队列: 会通过主线程执行UI刷新, 用户输入处理等任务 12//主队列（主线程执行任务）dispatch_queue_t queue = dispatch_get_main_queue(); 串行, 并行队列以及同步,异步函数的实践 异步函数 + 并发队列: 会开启多条新线程，队列中的任务异步执行 123456789101112131415161718192021- (void)asyncConcurrent { //1.创建队列 -- 并发队列 dispatch_queue_t queue = dispatch_queue_create(&quot;conQueue&quot;, DISPATCH_QUEUE_CONCURRENT); //2.封装异步任务并添加到队列中 /* 参数1：队列名 参数2：要执行的任务 */ //测试是否开启了多条线程 dispatch_async(queue, ^{ NSLog(@&quot;download1 --- %@&quot;, [NSThread currentThread]); }); dispatch_async(queue, ^{ NSLog(@&quot;download1 --- %@&quot;, [NSThread currentThread]); }); dispatch_async(queue, ^{ NSLog(@&quot;download1 --- %@&quot;, [NSThread currentThread]); });} 异步函数 + 串行队列 – 会开启一条新线程，队列中的任务串行执行 123456789101112131415- (void)asyncSerial { //创建队列 -- 串行队列 dispatch_queue_t queue = dispatch_queue_create(&quot;serQueue&quot;, DISPATCH_QUEUE_SERIAL); //异步函数 dispatch_async(queue, ^{ NSLog(@&quot;download1 --- %@&quot;, [NSThread currentThread]); }); dispatch_async(queue, ^{ NSLog(@&quot;download1 --- %@&quot;, [NSThread currentThread]); }); dispatch_async(queue, ^{ NSLog(@&quot;download1 --- %@&quot;, [NSThread currentThread]); });} 异步函数 + 主队列: 不会开启线程，队列中任务都在主线程中执行 123456789101112131415- (void)asyncMain { //创建主队列 dispatch_queue_t queue = dispatch_get_main_queue(); //异步函数 dispatch_async(queue, ^{ NSLog(@&quot;download1 --- %@&quot;, [NSThread currentThread]); }); dispatch_async(queue, ^{ NSLog(@&quot;download1 --- %@&quot;, [NSThread currentThread]); }); dispatch_async(queuaaa NSLog(@&quot;download1 --- %@&quot;, [NSThread currentThread]); });} 同步函数 + 并发队列: 不会开启新线程 123456789101112131415- (void)syncConcurrent { //创建并发队列 dispatch_queue_t queue = dispatch_queue_create(&quot;conQueue&quot;, DISPATCH_QUEUE_CONCURRENT); //同步函数 dispatch_sync(queue, ^{ NSLog(@&quot;download1 --- %@&quot;, [NSThread currentThread]); }); dispatch_sync(queue, ^{ NSLog(@&quot;download1 --- %@&quot;, [NSThread currentThread]); }); dispatch_sync(queue, ^{ NSLog(@&quot;download1 --- %@&quot;, [NSThread currentThread]); });} 同步函数 + 串行队列: 不会开启线程 123456789101112131415- (void)syncSerial { //创建串行队列 dispatch_queue_t queue = dispatch_queue_create(&quot;serQueue&quot;, DISPATCH_QUEUE_SERIAL); //同步函数 dispatch_sync(queue, ^{ NSLog(@&quot;download1 --- %@&quot;, [NSThread currentThread]); }); dispatch_sync(queue, ^{ NSLog(@&quot;download1 --- %@&quot;, [NSThread currentThread]); }); dispatch_sync(queue, ^{ NSLog(@&quot;download1 --- %@&quot;, [NSThread currentThread]); });} 同步函数 + 主队列: 产生死锁 避免死锁: 用子线程调用syncMain()123456789101112131415- (void)syncMain { //创建主队列 dispatch_queue_t queue = dispatch_get_main_queue(); //同步函数 dispatch_sync(queue, ^{ NSLog(@&quot;download1 --- %@&quot;, [NSThread currentThread]); }); dispatch_sync(queue, ^{ NSLog(@&quot;download1 --- %@&quot;, [NSThread currentThread]); }); dispatch_sync(queue, ^{ NSLog(@&quot;download1 --- %@&quot;, [NSThread currentThread]); });} 回到: [[多线程2__多线程开发#实现汇总]] gcd实现线程间通信1234567891011121314151617181920212223242526272829303132333435363738//网络图片下载Demo -- GCD实现#import &quot;ViewController.h&quot;@interface ViewController ()@property(nonatomic, strong) UIImageView *imageView;@end@implementation ViewController- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event { //1.使用GCD开子线程 -- 使用异步函数 dispatch_async(dispatch_get_global_queue(0, 0), ^{ //获取全局并发队列 //封装任务 //确定图片URL NSURL *url = [NSURL URLWithString:@&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fa1.att.hudong.com%2F62%2F02%2F01300542526392139955025309984.jpg&amp;refer=http%3A%2F%2Fa1.att.hudong.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1613890070&amp;t=9b041b83f4ddfe8c165547120f5aa589&quot;]; //根据URL下载图片二进制数据到本地 NSData *imageData = [NSData dataWithContentsOfURL:url]; //图片格式转换 UIImage *image = [UIImage imageWithData:imageData]; //更新UI dispatch_async(dispatch_get_main_queue(), ^{ self.imageView.image = image; NSLog(@&quot;UI--- %@&quot;, [NSThread currentThread]); }); //同步函数更新UI dispatch_sync(dispatch_get_main_queue(), ^{ //此时任务在子线程中执行，因此使用主队列不会造成死锁 self.imageView.image = image; NSLog(@&quot;UI--- %@&quot;, [NSThread currentThread]); }); });}@end 回到: [[多线程2__多线程开发#线程间通信]] gcd注意事项通过dispatch_async(queue, ^{block})将block追加到dispatch queue(无论Concurrent或Serial Queue)中后, 立即通过dispatch_release(queue)释放, 是否会影响block的执行?不会. 首先: dispatch_async或dispatch_sync表示追加异步或同步任务到串行队列或并发队列中执行. queue并不是OC中类似”block”的对象, 因此没有ARC来自动管理它的内存, 因此需要手动对它(队列对象)进行释放 其次: 通过 dispatch_async将block追加到queue中, 本质上该block通过dispatch retain持有了queue. 因此就算在追加后立即对queue进行release操作, 该queue由于被block持有也不会废弃, 因此block能够正常执行.","link":"/2024/07/04/iOS/iOS_gcd/"},{"title":"iOS之设计模式","text":"MVC (Model-View-Controller)1. Model","link":"/2024/07/04/iOS/iOS_iOS%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"UI控件","text":"UI控件UIView 视图类用法： UIView *view = [[UIView alloc] init]; 常见属性 1. 获得自己的父控件对象 @property (nonatomic, readonly) UIView *superview; //父控件只有一个 2. 获得自己的子控件对象 @property (nonatomic, readonly) NSArray *subviews; //子控件可能有很多个 3. 获得控件的Tag @property(nonatomic) NSInteger tag; 4. 控件的形变属性 -- 旋转角度，比例缩放，平移等 @property(nonatomic) CGAffineTransform transform; 5. 控件矩形框在父控件上的位置和尺寸 @property(nonatomic) CGRect frame; 用法： targetView.frame = CGRectMake(x, y, width, height); 6. 控件矩形的位置和尺寸（以自己为坐标原点） @property(nonatomic) CGRect bounds; 7. 控件中点的位置（控件中心点） @property(nonatomic) CGpoint center; 常用方法： 1. 添加一个子控件 - (void) addSubview: (UIView *) view; 用法： [self.view addSubview(targetView)]; 2. 将自己从父控件中移除 - (void) removeFromSuperview; 用法： [targetView removeFromSuperView]; UILabel 标签类 – 父类：UIView用法： UILabel *label = [[UILabel alloc] init]; 常见属性：(可使用父类的属性) 1. 显示的文字 @property(nonatomic, copy) NSString *text; 2. 显示的字体,可设置字体的大小 @property(nonatomic, retain) UIFont *font; 3. 文字的颜色 @property(nonatomic) UIColor *textColor; 4. 背景颜色 @property(nonatomic) UIColor *backgroundColor; 5. 对齐的样式 @property(nonatomic) NSTextAlignment; textAlignment; 6. 文字行数 @property(nonatomic) NSInteger numberOfLines; 7. 换行模式 @property(nonatomic) NSLineBreakMode lineBreakMode; 8. 设置阴影 @property(nontaomic) UIColor *shadowColor; 9. 阴影显示位置 @property(nonatomic) CGSize shadowOffset; UIImageVIew 图像视图 – 父类：UIView用法： UIImageView *imageView = [[UIImageView alloc] init]; 常见属性：(可用父类属性) 1. 设置要显示的图片 @property (nullable, nonatomic, strong) UIImage *image; 使用： imageView.image = [UIImage imageNamed: @&quot;1&quot;]; 2. 设置图片的样式（枚举） @property(nonatomic) UIViewContentMode contentMode; UIButton 按钮控件 – 父类：UIControl &lt;- UIView用法： 按钮状态： 1. 普通状态 normal 对应情况：Default 枚举常量： UIControlStateNormal 2. 高亮状态 highlighted 枚举常量： UIControlStateHighlihted 3. 失效状态 disabled 枚举常量： UIControlStatedisabled 常用属性：(可使用父类属性) 注意有些属性需要对应按钮的不同状态分别设置 1. 设置按钮类型（枚举类型） @property(nonatomic,readonly) UIButtonType buttonType; 使用： 结合按钮初始化方法一起使用： UIButton *button = [UIButton buttonWithType: 枚举类型的状态变量]; 2. 常用方法： 以set开头的设置方法，可去类文件中查找并使用 1. 设置文字标题 setTitle: forState: 2. 设置内容图片 setImage: forState: 3. 设置背景图片 setBackgroundImage: forState: 4. 设置点击按钮执行的方法 - (IBACtion) clickbutton (UIButton *) sender; 5. 监听按钮点击 addTarget: (让谁做事情 -- self) action: @selector(做什么事情 -- 方法) forControlEvent: (事件 -- 对按钮触发了怎样的事件) UITableView","link":"/2024/07/04/iOS/iOS_UI%E6%8E%A7%E4%BB%B6/"},{"title":"pthread","text":"1234567891011121314151617181920212223242526// ViewController.m#import &lt;pthread.h&gt;- (void)viewDidLoad { [super viewDidLoad]; //1.创建线程对象 pthread_t thread; //2.线程创建函数 //1).线程对象 -- 地址传递 //2).线程的属性 //3).指向函数的指针 //4).前面函数要接收的参数 -- NULL pthread_create(&amp;thread, NULL, func, NULL); //3.判断两条线程是否相等 pthread_equal();}void *func(*void) { NSLog(@&quot;%@-----&quot;, [NSThread currentThread]); return NULL;} [[多线程2__多线程开发#实现汇总]]","link":"/2024/07/04/iOS/iOS_pthread/"},{"title":"数据竞争","text":"数据竞争代码举例以及用互斥锁解决123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// ViewController.m//售票员卖票demo@interface ViewController() @property(nonatomic, strong) NSThread *threadA;@property(nonatomic, strong) NSThread *threadB;@property(nonatomic, strong) NSThread *threadC; @end @implementation ViewController- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event { self.ticketCount = 100; //开启三个售票员线程 self.threadA = [[NSThread alloc] initWithTarget:self selector:@selector(saleTicket) object:nil]; self.threadB = [[NSThread alloc] initWithTarget:self selector:@selector(saleTicket) object:nil]; self.threadC = [[NSThread alloc] initWithTarget:self selector:@selector(saleTicket) object:nil]; //线程属性设置 self.threadA.name = @&quot;售票员A&quot;; self.threadB.name = @&quot;售票员B&quot;; self.threadC.name = @&quot;售票员C&quot;; //启动线程 [self.threadA start]; [self.threadB start]; [self.threadC start]; }- (void)saleTicket { while(1) { @synchronized (self) { //对于每一次卖票的模块上锁，保证同一时间只有一位售票员在卖票 if(self.ticketCount &gt; 0) { //卖出去一张票 for(int i = 1; i &lt;= 100000; i++); //增加程序执行时间，方便观察结果 NSLog(@&quot;%@卖出去一张，还剩下%zd张&quot;, [NSThread currentThread].name, self.ticketCount - 1); self.ticketCount--; } else { NSLog(@&quot;票已售罄&quot;); break; } } }}@end","link":"/2024/07/04/iOS/iOS_datarace/"},{"title":"多线程1__多线程概念","text":"记录iOS多线程开发的知识和使用方法, 积累iOS开发经验~~~ 一些基本概念 一个应用程序可以对应多个进程, 每个进程中至少有一个线程, 进程中的线程共享该进程的资源. 线程执行任务的方式 – 串行（任务和任务之间有执行顺序，即多个任务一个一个地按顺序执行，一个线程同时只能执行一个任务） 单个进程中的每条线程可以并行执行任务 同一时间CPU只能处理一条线程，即只有一条线程在工作. 所以多线程并发执行，实则是CPU快速地在线程之间调度切换. 多线程的优缺点 优点 适当提高程序的执行效率和资源利用率 缺点 空间开销：内核数据结构，栈空间 时间开销：约90ms的创建时间 性能降低：在开启大量线程时降低程序性能，同时CPU调度线程时开销更大 程序设计：线程之间通信，多线程数据共享（同一数据被多个线程共享导致数据安全问题）更加复杂 主线程与子线程 主线程的概念一个iOS程序运行后，默认开启一条“主线程”或“UI线程” 主线程的作用 显示/刷新UI 处理UI事件（点击，滚动，拖拽等） 主线程注意事项 凡是和UI相关的操作必须在主线程中执行 不要将耗时操作放在主线程中 – 会卡住主线程，严重影响UI流畅度，降低用户体验 子线程的概念用来执行耗时操作的线程 多线程实现方案 技术方案 简介 语言 线程生命周期 使用频率 [[pthread]] 1.通用的多线程API2.适用于Unix/Linux/Windows等系统3.跨平台/可移植4.使用难度较大 C语言 程序员管理 少 [[NSThread]] 1.更加面向对象2.简单易用，可直接操作线程对象 OC 程序员管理 正常 [[gcd]] 1.旨在代替NSThread等线程技术2.充分利用设备的多核资源 C 自动管理 经常使用 NSOperation 1.基于GCD，增加了一些简单功能2.更加面向对象 OC 自动管理 经常使用 多线程安全问题 数据竞争当多个线程同时访问和修改同一共享资源且至少一个是写操作时，会导致数据竞争。 死锁当两个或多个线程互相等待对方释放资源时，会导致死锁，所有相关线程都会被永远阻塞。 线程饥饿(Thread Starvation)当某些线程长时间得不到资源访问权时，会导致线程饥饿问题。 上下文切换开销(Context Switching Overhead)上下文切换开销是指CPU在不同线程之间切换时保存和恢复线程状态的过程. 频繁的上下文切换会导致性能开销增加，影响应用的响应速度和效率。 12345678910111213141516dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.concurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);// 问题举例 for (int i = 0; i &lt; 1000; i++) { dispatch_async(queue, ^{ NSLog(@&quot;Task %d&quot;, i); });}// 解决方法// 减少任务的数量或调整任务的粒度，减少不必要的上下文切换。dispatch_async(queue, ^{ for (int i = 0; i &lt; 1000; i++) { NSLog(@&quot;Task %d&quot;, i); }}); 保证线程安全的方式 使用同步机制 互斥锁 (Mutex) : 使用 @synchronized、NSLock、pthread_mutex 等来保护临界区，确保同一时刻只有一个线程可以访问共享资源。 递归锁 (NSRecursiveLock): 用于允许同一线程多次获得同一个锁，而不会导致死锁。 条件锁 (NSConditionLock): 用于处理线程之间的依赖关系，允许线程在某个条件满足时继续执行。 使用gcd 串行队列 并发队列 异步任务 使用原子操作 OSAtomic: 提供一些原子操作函数，如 OSAtomicIncrement32，但在 iOS 10 之后被 stdatomic 替代。 stdatomic: C11 标准库中的原子操作，提供对基本类型的原子读写操作。 使用线程安全的容器 NSOperationQueue: 提供了更高级的线程管理和任务调度机制，适用于需要更复杂依赖关系和优先级管理的场景。 线程安全的集合类: 如 NSCache 等，内部已经实现了线程安全机制。 避免共享状态 尽量减少共享状态，通过消息传递或复制数据来避免多个线程同时访问同一个资源。 使用不可变对象 尽可能使用不可变对象（如 NSString、NSArray 等），避免在多个线程中修改同一个对象的状态。 线程间通信 概念A线程传递数据给B线程A线程执行完特定任务后，转到B线程继续执行任务 [[NSThread#线程间通信实现]] [[gcd#gcd实现线程间通信]]","link":"/2024/07/04/iOS/iOS_%E5%A4%9A%E7%BA%BF%E7%A8%8B1__%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5/"},{"title":"block","text":"block","link":"/2024/07/04/iOS/iOS_block/"},{"title":"单例模式","text":"单例模式一.单例模式1.它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。二.单例模式的作用1.保证在程序运行过程中，一个类只有一个实例，该实例易于供外界访问，从而方便地控制了实例个数，节约系统资源三.单例模式的使用场合1.在整个应用程序中，需要共享一份资源（资源只需要初始化一次）四.单例模式的实现1.ARC环境下实现单例模式方法：懒加载，类方法，协议实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//ToolBox.m#import &quot;ToolBox.h&quot;@interface ToolBox() &lt;NSCopying, NSMutableCopying&gt;@end@implementation ToolBox//0.提供全局变量static ToolBox *toolBox;//懒加载 --- 保证只分配一次存储空间//alloc -&gt; allocWithZone+ (instancetype)allocWithZone:(struct _NSZone *)zone { //线程安全问题 //1.互斥锁// @synchronized (self) {// if(toolBox == nil) {// toolBox = [super allocWithZone:zone];// }// } //2.GCD一次性代码 -- 程序运行期间只执行一次 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ toolBox = [super allocWithZone:zone]; }); return toolBox;} //类方法//1.方便访问 -- 外界只需调用类方法获得该类实例//2.表明身份 -- 从类方法识别该类是单例//3.命名规范 -- share+类名|default+类名|share|default|类名+(instancetype)shareTool { return [[self alloc] init];}//协议实现//copy -&gt; copyWithZone- (id)copyWithZone:(NSZone *)zone { return toolBox;}//mutableCopy -&gt; mutableCopyWithZone- (id)mutableCopyWithZone:(NSZone *)zone { return toolBox;}@end 12345678910111213141516171819202122232425262728//ViewController.m#import &quot;ViewController.h&quot;#import &quot;ToolBox.h&quot;@implementation ViewController//ARC环境下实现单例模式- (void)viewDidLoad { [super viewDidLoad]; //1.懒加载实现 ToolBox *tool1 = [[ToolBox alloc] init]; ToolBox *tool2 = [[ToolBox alloc] init]; ToolBox *tool3 = [ToolBox new]; //2.类方法实现 ToolBox *tool4 = [ToolBox shareTool]; //3.实现协议中的copy方法，将已有的toolBox对象返回即可 ToolBox *tool5 = [tool1 copy]; ToolBox *tool6 = [tool1 mutableCopy]; NSLog(@&quot;t1:%p t2:%p t3:%p t4:%p t5:%p t6:%p&quot;, tool1, tool2, tool3, tool4, tool5, tool6);}@end [[观察者模式]]","link":"/2024/07/04/iOS/iOS_%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"title":"观察者模式","text":"观察者模式一. 什么是观察者模式 观察者模式定义：观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 iOS中实现观察者模式：Notification、KVO。 二. Notification – 通知现有对象A和B，A对B的变化感兴趣，就注册为B的观察者，当B发生变化时通知A，告知B发生了变化。 对于感兴趣的A来说，在A这里定义通知，也就是注册观察者（A就是观察者，定义怎么观察的以及观察到了会做些什么） 123456789//注册观察者[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(notice:) name:@&quot;tongzhi&quot; object:nil];//观察到变化后做什么事情- (void)notice:(id)sender { NSLog(@&quot;%@&quot;, sender);} 对于变化源B来说，在B这里发出通知 12345678//创建通知对象//Name是通知的名称 object是通知的发布者，也就是发布通知的对象 userInfo是一些额外的信息， 字典类NSNotification *notification = [NSNotification notificationWithName:@&quot;tongzhi&quot; object:nil userInfo:nil];//发送通知[[NSNotificationCenter defaultCenter] postNotification:notification]; 在dealloc中移除观察者 1234- (void)dealloc { //根据name和object删除对应的观察者，如果object设置为nil，则删除所有name匹配的观察者 [[NSNotificationCenter defaultCenter] removeObserver:self name:@&quot;tongzhi&quot; object:nil];} 三. KVO – Key Value ObservingKVO，即键值观察，它是观察着模式的一种衍生。其基本思想是，对目标对象的某属性添加观察，当该属性发生变化时，会自动通知观察者。相比于NotificationCenter的post通知来说简单了许多。 首先，给目标对象的属性添加观察 1234- (void)addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld //能够记录旧值和新值 context:nil 其次，实现下面方法来接收通知（当被观察的属性发生变化时，观察者立马会得到通知） 12345678910- (void)observeValueForKeyPath:(nullable NSString *)keyPath //目标属性，需判断是否和自己所观察的属性一致 ofObject:(nullable id)object //目标对象，需判断是否和自己所观察的对象一致 change:(nullable NSDictionary&lt;NSString*, id&gt; *)change context:nil //如果收到的通知经过判断不是自己要观察的，则将该情况交给父类处理，因为父类也有可能使用了KVO//[super observeValueForKeyPath:keyPath ofObject:object change:change context:context]; 最后，移除观察者 1- (void)removeObserver:self forKeyPath:@“name”; 四. KVO的原理当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中被观察属性的 setter 方法，在setter方法里使其具有通知机制。同时派生类还重写了 class 方法以“欺骗”外部调用者它就是起初的那个类。然后系统将这个对象的 isa 指针指向这个新诞生的派生类，因此这个对象就成为该派生类的对象了，因而在该对象上对 setter 的调用就会调用重写的 setter，从而激活键值通知机制。此外，派生类还重写了 dealloc 方法来释放资源。 在重写的setter里，给属性赋值的前后分别调用了两个方法： 12- (void)willChangeValueForKey:(NSString *)key; //赋值前- (void)didChangeValueForKey:(NSString *)key; //赋值后 在 - (void)didChangeValueForKey:(NSString *)key; 方法中会调用： 1234- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSString*, id&gt; *)change context:nil 五. KVO使用注意1. 只有使用属性的setter方法，或通过key-path来设置属性值，观察者对象才会获得通知常见的几种设置方式： 123456//1.遵循使用属性的setter方法self.name = @&quot;changed&quot;;[self setName:@&quot;changed&quot;];//2.通过key-path设置[self setValue:[NSString stringWithFormat:@&quot;changed&quot;] forKey:@&quot;name&quot;]; 2. 观察者在使用结束后一定要在dealloc中移除，否则会导致资源泄漏3. 通知方法（observeValueForKeyPath）中，change字典保存了属性变更的信息12NSLog(@&quot;the old value is %@&quot;, [change objectForKey:@&quot;old&quot;]); //旧值NSLog(@&quot;the new value is %@&quot;, [change objectForKey:@&quot;new&quot;]); //新值 [[单例模式]]","link":"/2024/07/04/iOS/iOS_%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"title":"多线程2__多线程开发","text":"","link":"/2024/07/04/iOS/iOS_%E5%A4%9A%E7%BA%BF%E7%A8%8B2__%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/"},{"title":"面经","text":"performSelector实现原理, 为什么通过这种方法调用不会崩 点击事件响应链","link":"/2024/07/04/iOS/iOS_%E9%9D%A2%E7%BB%8F/"},{"title":"markdown 常用语法总结","text":"总结了常用的markdown语法, 方便平常整理笔记时使用~~ 标题 使用 # 号表示标题，支持 1 到 6 级标题。 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 段落 段落之间需要空一行。 123这是一个段落。这是另一个段落。 强调 使用 * 或 _ 表示斜体，使用 ** 或 __ 表示粗体。 1234*斜体*_斜体_**粗体**__粗体__ 删除线 使用 ~~ 表示删除线。 1~~删除线~~ 引用 使用 &gt; 表示引用。 1&gt; 这是一个引用。 列表 无序列表使用 -、* 或 + 表示无序列表。 12345678910- 项目一- 项目二 - 子项目 - 子项目* 项目一* 项目二+ 项目一+ 项目二 有序列表使用数字加点表示有序列表。 12341. 项目一2. 项目二 1. 子项目 2. 子项目 链接 使用 显示文本 表示链接。 1[Google](https://www.google.com) 图片 使用 ![替代文本](图片地址) 插入图片。 1![描述](https://www.example.com/image.jpg) 代码 行内代码使用反引号 ` 表示行内代码。 1这是 `inline code`。 代码块使用三个反引号 ``` 或四个空格表示代码块。 123// ```javascript// console.log('Hello, world!');// ``` 表格 使用 | 和 - 创建表格。 1234| 标题一 | 标题二 || ------ | ------ || 单元格 | 单元格 || 单元格 | 单元格 | 水平线 使用三个及以上的 -、* 或 _ 表示水平线。 123---***___ 注脚 使用 [^注脚] 表示注脚。 123这是一个带注脚的文本[^1]。[^1]: 这是注脚内容。 任务列表 使用 - [ ] 表示未完成任务，- [x] 表示已完成任务。 12- [x] 已完成任务- [ ] 未完成任务 转义 使用反斜杠 \\ 转义特殊字符。 1\\*这个文本没有被强调\\*","link":"/2024/07/04/markdown/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"title":"多线程零碎记录","text":"2). 原子性与非原子性(线程安全相关内容)atomic 原子属性为setter方法加锁（默认为atomic） 线程安全，消耗大量资源 nonatomic 非原子属性不会为setter方法加锁 非线程安全，适合小内存移动设备 I 延迟执行1234567891011121314151617181920212223242526272829303132//ViewController.m- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event { [self delay];}//延迟执行- (void)delay { NSLog(@&quot;start---- delay running&quot;); //1.延迟执行的第一种方法 [self performSelector:@selector(task) withObject:nil afterDelay:2.0]; //2.0秒延迟之后执行 //2.延迟执行的第二种方法 [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(task) userInfo:nil repeats:YES]; //在2.0秒延迟之后每2.0秒执行一次task方法 //3.GCD实现延迟执行 /* 参数1：DISPATCH_TIME_NOW 从现在开始计算时间 参数2：延迟的时间 2.0 GCD时间单位：纳秒 参数3：队列 */ dispatch_queue_t queue = dispatch_get_main_queue(); //使用主队列 //dispatch_queue_t queue = dispatch_get_global_queue(0, 0); //使用全局并发队列 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), queue, ^{ //从现在开始计时，2.0*10e9纳秒延迟后执行block NSLog(@&quot;GCD --- %@&quot;, [NSThread currentThread]); });} - (void)task { NSLog(@&quot;task --- %@&quot;, [NSThread currentThread]);} II 一次性代码 – 不可放入懒加载中1234567//一次性代码 -- 整个应用程序运行期间只执行一次- (void)once { static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ NSLog(@&quot;---once---&quot;); });} III 栅栏函数 – 控制并发队列任务执行顺序(栅栏后的任务等待栅栏执行后才会执行)123456789101112131415161718192021222324252627282930//ViewController.m- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event { //0.创建并发队列 dispatch_queue_t que = dispatch_queue_create(&quot;download&quot;, DISPATCH_QUEUE_CONCURRENT); //1.异步函数开线程 dispatch_async(que, ^{ //任务1 NSLog(@&quot;download1---%@&quot;, [NSThread currentThread]); }); dispatch_async(que, ^{ //任务2 NSLog(@&quot;download2---%@&quot;, [NSThread currentThread]); }); //栅栏函数 -- 不可使用全局并发队列 dispatch_barrier_async(que, ^{ NSLog(@&quot;++++++++++++++++&quot;); }); dispatch_async(que, ^{ //任务3 NSLog(@&quot;download3---%@&quot;, [NSThread currentThread]); }); dispatch_async(que, ^{ //任务3 NSLog(@&quot;download4---%@&quot;, [NSThread currentThread]); });} IV 快速迭代123456789101112131415161718192021222324252627282930313233343536373839404142//文件剪切Demo -- 快速迭代并发遍历并剪切文件//开子线程和主线程一起完成并发任务，任务并发执行- (void)apply { /* 参数1：遍历次数 参数2：并发队列 参数3：遍历索引 */ dispatch_apply(100, dispatch_get_global_queue(0, 0), ^(size_t index) { NSLog(@&quot;%zd --- %@&quot;, index, [NSThread currentThread]); });}- (void)moveFile { //1.拿到文件路径 NSString *from = @&quot;/Users/qiaoyibo/Downloads/from&quot;; //2.获得目标文件路径 NSString *to = @&quot;/Users/qiaoyibo/Downloads/to&quot;; //3.得到目录下面的所有文件(名) NSArray *subPaths = [[NSFileManager defaultManager] subpathsAtPath:from]; //4.遍历所有文件，执行剪切操作 NSInteger count = subPaths.count; dispatch_apply(count, dispatch_get_global_queue(0, 0), ^(size_t i) { //4.1 拼接文件全路径 //拼接时自动添加路径间的'/' NSString *fullPath = [from stringByAppendingPathComponent:subPaths[i]]; NSString *tofullPath = [to stringByAppendingPathComponent:subPaths[i]]; //4.2 执行剪切操作 /* 参数1：要剪切的文件在哪 参数2：文件应该被存放到哪里 参数3：默认为nil */ [[NSFileManager defaultManager] moveItemAtPath:fullPath toPath:tofullPath error:nil]; });} V 队列组1234567891011121314151617181920212223242526272829//队列组的拦截监听作用- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event { //1.创建队列 dispatch_queue_t queue = dispatch_get_global_queue(0,0); //2.创建队列组 dispatch_group_t group = dispatch_group_create(); //异步函数 /* 1)封装任务 2)把任务添加到队列中 3)会监听任务的执行情况，通知group */ dispatch_group_async(group, queue, ^{ NSLog(@&quot;1-----%@&quot;, [NSThread currentThread]); }); dispatch_group_async(group, queue, ^{ NSLog(@&quot;2-----%@&quot;, [NSThread currentThread]); }); dispatch_group_async(group, queue, ^{ NSLog(@&quot;3-----%@&quot;, [NSThread currentThread]); }); //拦截通知，当队列组中所有的任务都执行完毕的时候会进入到下面的方法 dispatch_group_notify(group, queue, ^{ NSLog(@&quot;-----拦截任务组-----&quot;); });} 12345678910111213141516171819202122232425262728293031323334353637383940//将后续任务加入队列组- (void)test { //1.创建队列 dispatch_queue_t queue = dispatch_get_global_queue(0, 0); //2.创建队列组 dispatch_group_t group = dispatch_group_create(); //3.在该方法后面的”异步任务“会被纳入到队列组监听范围，进入群组 //enter和leave 必须配对使用 dispatch_group_enter(group); dispatch_async(queue, ^{ NSLog(@&quot;1----%@&quot;, [NSThread currentThread]); //离开群组 dispatch_group_leave(group); }); dispatch_group_enter(group); dispatch_async(queue, ^{ NSLog(@&quot;2----%@&quot;, [NSThread currentThread]); dispatch_group_leave(group); }); //拦截通知 //该方法是异步的 dispatch_group_notify(group, queue, ^{ NSLog(@&quot;------dispatch_group_notify-------&quot;); }); NSLog(@&quot;------dispatch_group_notify------&quot;);//异步测试 //等待（死等） //该方法是阻塞的 dispatch_group_wait(group, DISPATCH_TIME_FOREVER); NSLog(@&quot;------dispatch_group_wait------&quot;); //阻塞测试} 123456789101112131415161718192021222324252627282930313233343536373839404142434445//下载图片1和2，合成并显示图片- (void)test { //获得全局并发队列 dispatch_queue_t queue = dispatch_get_global_queue(0, 0); //获取队列组 dispatch_group_t group = dispatch_group_create(); //开子线程下载图片1 dispatch_group_async(queue, group, ^{ NSURL *url = [NSURL URLWithString:@&quot;&quot;]; NSData *imageData = [NSData dataWithContentsOfURL:url]; UIImage *image1 = [UIImage imageWithData:imageData]; }); //开子线程下载图片2 dispatch_group_async(queue, group, ^{ NSURL *url = [NSURL URLWithString:@&quot;&quot;]; NSData *imageData = [NSData dataWithContentsOfURL:url]; UIImage *image1 = [UIImage imageWithData:imageData]; }); //合成图片 dispatch_group_notify(group, queue, ^{ //创建图形上下文 UIGraphicsBeginImageContext(CGSizeMake(200, 200)); //画图1 [self.image1 drawInRect:CGRectMake(0, 0, 200, 200)]; //画图2 [self.image2 drawInRect:CGRectMake(0, 100, 200, 100)]; //根据上下文得到一张图片 UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); //关闭上下文 UIGraphicsEndImageContext(); //更新UI dispatch_async(dispatch_get_main_queue(), ^{ NSLog(@&quot;UI---------%@&quot;, [NSThread currentThread]); self.imageView.image = image; }); });}","link":"/2024/07/04/iOS/iOS_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9B%B6%E7%A2%8E%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Python列表","slug":"Python列表","link":"/tags/Python%E5%88%97%E8%A1%A8/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"网络请求","slug":"网络请求","link":"/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"},{"name":"第三方库","slug":"第三方库","link":"/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"},{"name":"Objective-C","slug":"Objective-C","link":"/tags/Objective-C/"},{"name":"内存管理","slug":"内存管理","link":"/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"多线程","slug":"多线程","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"}],"categories":[{"name":"Python数据结构","slug":"Python数据结构","link":"/categories/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"iOS第三方库","slug":"iOS第三方库","link":"/categories/iOS%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"},{"name":"iOS语言","slug":"iOS语言","link":"/categories/iOS%E8%AF%AD%E8%A8%80/"},{"name":"iOS内存管理","slug":"iOS内存管理","link":"/categories/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"iOS网络请求数据处理","slug":"iOS第三方库/iOS网络请求数据处理","link":"/categories/iOS%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/iOS%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"iOS","slug":"iOS","link":"/categories/iOS/"},{"name":"Objective-C","slug":"iOS/Objective-C","link":"/categories/iOS/Objective-C/"},{"name":"iOS多线程","slug":"iOS多线程","link":"/categories/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"iOS设计模式","slug":"iOS设计模式","link":"/categories/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"多线程","slug":"iOS/多线程","link":"/categories/iOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"markdown常用语法","slug":"markdown常用语法","link":"/categories/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"}],"pages":[]}